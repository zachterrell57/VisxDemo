import {
  require_baseGetTag,
  require_isObject,
  require_root
} from "./chunk-MDMDGUUI.js";
import {
  require_react
} from "./chunk-5SDAPIJE.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/reduce-css-calc/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/reduce-css-calc/node_modules/balanced-match/index.js"(exports, module) {
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match2 = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/reduce-function-call/index.js
var require_reduce_function_call = __commonJS({
  "node_modules/reduce-function-call/index.js"(exports, module) {
    var balanced = require_balanced_match2();
    module.exports = reduceFunctionCall;
    function reduceFunctionCall(string, functionRE, callback) {
      var call = string;
      return getFunctionCalls(string, functionRE).reduce(function(string2, obj) {
        return string2.replace(obj.functionIdentifier + "(" + obj.matches.body + ")", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE));
      }, string);
    }
    function getFunctionCalls(call, functionRE) {
      var expressions = [];
      var fnRE = typeof functionRE === "string" ? new RegExp("\\b(" + functionRE + ")\\(") : functionRE;
      do {
        var searchMatch = fnRE.exec(call);
        if (!searchMatch) {
          return expressions;
        }
        if (searchMatch[1] === void 0) {
          throw new Error("Missing the first couple of parenthesis to get the function identifier in " + functionRE);
        }
        var fn = searchMatch[1];
        var startIndex = searchMatch.index;
        var matches = balanced("(", ")", call.substring(startIndex));
        if (!matches || matches.start !== searchMatch[0].length - 1) {
          throw new SyntaxError(fn + "(): missing closing ')' in the value '" + call + "'");
        }
        expressions.push({ matches, functionIdentifier: fn });
        call = matches.post;
      } while (fnRE.test(call));
      return expressions;
    }
    function evalFunctionCall(string, functionIdentifier, callback, call, functionRE) {
      return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call);
    }
  }
});

// node_modules/math-expression-evaluator/src/math_function.js
var require_math_function = __commonJS({
  "node_modules/math-expression-evaluator/src/math_function.js"(exports, module) {
    "use strict";
    var Mexp = function(parsed) {
      this.value = parsed;
    };
    Mexp.math = {
      isDegree: true,
      acos: function(x) {
        return Mexp.math.isDegree ? 180 / Math.PI * Math.acos(x) : Math.acos(x);
      },
      add: function(a, b) {
        return a + b;
      },
      asin: function(x) {
        return Mexp.math.isDegree ? 180 / Math.PI * Math.asin(x) : Math.asin(x);
      },
      atan: function(x) {
        return Mexp.math.isDegree ? 180 / Math.PI * Math.atan(x) : Math.atan(x);
      },
      acosh: function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      },
      asinh: function(x) {
        return Math.log(x + Math.sqrt(x * x + 1));
      },
      atanh: function(x) {
        return Math.log((1 + x) / (1 - x));
      },
      C: function(n, r) {
        var pro = 1;
        var other = n - r;
        var choice = r;
        if (choice < other) {
          choice = other;
          other = r;
        }
        for (var i = choice + 1; i <= n; i++) {
          pro *= i;
        }
        return pro / Mexp.math.fact(other);
      },
      changeSign: function(x) {
        return -x;
      },
      cos: function(x) {
        if (Mexp.math.isDegree)
          x = Mexp.math.toRadian(x);
        return Math.cos(x);
      },
      cosh: function(x) {
        return (Math.pow(Math.E, x) + Math.pow(Math.E, -1 * x)) / 2;
      },
      div: function(a, b) {
        return a / b;
      },
      fact: function(n) {
        if (n % 1 !== 0)
          return "NaN";
        var pro = 1;
        for (var i = 2; i <= n; i++) {
          pro *= i;
        }
        return pro;
      },
      inverse: function(x) {
        return 1 / x;
      },
      log: function(i) {
        return Math.log(i) / Math.log(10);
      },
      mod: function(a, b) {
        return a % b;
      },
      mul: function(a, b) {
        return a * b;
      },
      P: function(n, r) {
        var pro = 1;
        for (var i = Math.floor(n) - Math.floor(r) + 1; i <= Math.floor(n); i++) {
          pro *= i;
        }
        return pro;
      },
      Pi: function(low, high, ex) {
        var pro = 1;
        for (var i = low; i <= high; i++) {
          pro *= Number(ex.postfixEval({
            n: i
          }));
        }
        return pro;
      },
      pow10x: function(e) {
        var x = 1;
        while (e--) {
          x *= 10;
        }
        return x;
      },
      sigma: function(low, high, ex) {
        var sum = 0;
        for (var i = low; i <= high; i++) {
          sum += Number(ex.postfixEval({
            n: i
          }));
        }
        return sum;
      },
      sin: function(x) {
        if (Mexp.math.isDegree)
          x = Mexp.math.toRadian(x);
        return Math.sin(x);
      },
      sinh: function(x) {
        return (Math.pow(Math.E, x) - Math.pow(Math.E, -1 * x)) / 2;
      },
      sub: function(a, b) {
        return a - b;
      },
      tan: function(x) {
        if (Mexp.math.isDegree)
          x = Mexp.math.toRadian(x);
        return Math.tan(x);
      },
      tanh: function(x) {
        return Mexp.sinha(x) / Mexp.cosha(x);
      },
      toRadian: function(x) {
        return x * Math.PI / 180;
      },
      and: function(a, b) {
        return a & b;
      }
    };
    Mexp.Exception = function(message) {
      this.message = message;
    };
    module.exports = Mexp;
  }
});

// node_modules/math-expression-evaluator/src/lexer.js
var require_lexer = __commonJS({
  "node_modules/math-expression-evaluator/src/lexer.js"(exports, module) {
    "use strict";
    var Mexp = require_math_function();
    function inc(arr, val) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        arr[i2] += val;
      }
      return arr;
    }
    var tokens = [
      { token: "sin", show: "sin", type: 0, value: Mexp.math.sin },
      { token: "cos", show: "cos", type: 0, value: Mexp.math.cos },
      { token: "tan", show: "tan", type: 0, value: Mexp.math.tan },
      { token: "pi", show: "&pi;", type: 3, value: "PI" },
      { token: "(", show: "(", type: 4, value: "(" },
      { token: ")", show: ")", type: 5, value: ")" },
      { token: "P", show: "P", type: 10, value: Mexp.math.P },
      { token: "C", show: "C", type: 10, value: Mexp.math.C },
      { token: " ", show: " ", type: 14, value: " ".anchor },
      { token: "asin", show: "asin", type: 0, value: Mexp.math.asin },
      { token: "acos", show: "acos", type: 0, value: Mexp.math.acos },
      { token: "atan", show: "atan", type: 0, value: Mexp.math.atan },
      { token: "7", show: "7", type: 1, value: "7" },
      { token: "8", show: "8", type: 1, value: "8" },
      { token: "9", show: "9", type: 1, value: "9" },
      { token: "int", show: "Int", type: 0, value: Math.floor },
      { token: "cosh", show: "cosh", type: 0, value: Mexp.math.cosh },
      { token: "acosh", show: "acosh", type: 0, value: Mexp.math.acosh },
      { token: "ln", show: " ln", type: 0, value: Math.log },
      { token: "^", show: "^", type: 10, value: Math.pow },
      { token: "root", show: "root", type: 0, value: Math.sqrt },
      { token: "4", show: "4", type: 1, value: "4" },
      { token: "5", show: "5", type: 1, value: "5" },
      { token: "6", show: "6", type: 1, value: "6" },
      { token: "/", show: "&divide;", type: 2, value: Mexp.math.div },
      { token: "!", show: "!", type: 7, value: Mexp.math.fact },
      { token: "tanh", show: "tanh", type: 0, value: Mexp.math.tanh },
      { token: "atanh", show: "atanh", type: 0, value: Mexp.math.atanh },
      { token: "Mod", show: " Mod ", type: 2, value: Mexp.math.mod },
      { token: "1", show: "1", type: 1, value: "1" },
      { token: "2", show: "2", type: 1, value: "2" },
      { token: "3", show: "3", type: 1, value: "3" },
      { token: "*", show: "&times;", type: 2, value: Mexp.math.mul },
      { token: "sinh", show: "sinh", type: 0, value: Mexp.math.sinh },
      { token: "asinh", show: "asinh", type: 0, value: Mexp.math.asinh },
      { token: "e", show: "e", type: 3, value: "E" },
      { token: "log", show: " log", type: 0, value: Mexp.math.log },
      { token: "0", show: "0", type: 1, value: "0" },
      { token: ".", show: ".", type: 6, value: "." },
      { token: "+", show: "+", type: 9, value: Mexp.math.add },
      { token: "-", show: "-", type: 9, value: Mexp.math.sub },
      { token: ",", show: ",", type: 11, value: "," },
      { token: "Sigma", show: "&Sigma;", type: 12, value: Mexp.math.sigma },
      { token: "n", show: "n", type: 13, value: "n" },
      { token: "Pi", show: "&Pi;", type: 12, value: Mexp.math.Pi },
      { token: "pow", show: "pow", type: 8, value: Math.pow, numberOfArguments: 2 },
      { token: "&", show: "&", type: 9, value: Mexp.math.and }
    ];
    var preced = {
      0: 11,
      1: 0,
      2: 3,
      3: 0,
      4: 0,
      5: 0,
      6: 0,
      7: 11,
      8: 11,
      9: 1,
      10: 10,
      11: 0,
      12: 11,
      13: 0,
      14: -1,
      15: 11
    };
    for (i = 0; i < tokens.length; i++) {
      tokens[i].precedence = preced[tokens[i].type];
    }
    var i;
    var type0 = {
      0: true,
      1: true,
      3: true,
      4: true,
      6: true,
      8: true,
      9: true,
      12: true,
      13: true,
      14: true,
      15: true
    };
    var type1 = {
      0: true,
      1: true,
      2: true,
      3: true,
      4: true,
      5: true,
      6: true,
      7: true,
      8: true,
      9: true,
      10: true,
      11: true,
      12: true,
      13: true,
      15: true
    };
    var type1Asterick = {
      0: true,
      3: true,
      4: true,
      8: true,
      12: true,
      13: true,
      15: true
    };
    var empty = {};
    var type3Asterick = {
      0: true,
      1: true,
      3: true,
      4: true,
      6: true,
      8: true,
      12: true,
      13: true,
      15: true
    };
    var type6 = {
      1: true
    };
    var newAr = [
      [],
      [
        "1",
        "2",
        "3",
        "7",
        "8",
        "9",
        "4",
        "5",
        "6",
        "+",
        "-",
        "*",
        "/",
        "(",
        ")",
        "^",
        "!",
        "P",
        "C",
        "e",
        "0",
        ".",
        ",",
        "n",
        " ",
        "&"
      ],
      ["pi", "ln", "Pi"],
      ["sin", "cos", "tan", "Del", "int", "Mod", "log", "pow"],
      ["asin", "acos", "atan", "cosh", "root", "tanh", "sinh"],
      ["acosh", "atanh", "asinh", "Sigma"]
    ];
    function match(str1, str2, i2, x) {
      for (var f = 0; f < x; f++) {
        if (str1[i2 + f] !== str2[f]) {
          return false;
        }
      }
      return true;
    }
    Mexp.tokenTypes = {
      FUNCTION_WITH_ONE_ARG: 0,
      NUMBER: 1,
      BINARY_OPERATOR_HIGH_PRECENDENCE: 2,
      CONSTANT: 3,
      OPENING_PARENTHESIS: 4,
      CLOSING_PARENTHESIS: 5,
      DECIMAL: 6,
      POSTFIX_FUNCTION_WITH_ONE_ARG: 7,
      FUNCTION_WITH_N_ARGS: 8,
      BINARY_OPERATOR_LOW_PRECENDENCE: 9,
      BINARY_OPERATOR_PERMUTATION: 10,
      COMMA: 11,
      EVALUATED_FUNCTION: 12,
      EVALUATED_FUNCTION_PARAMETER: 13,
      SPACE: 14
    };
    Mexp.addToken = function(newTokens) {
      for (var i2 = 0; i2 < newTokens.length; i2++) {
        var x = newTokens[i2].token.length;
        var temp = -1;
        if (newTokens[i2].type === Mexp.tokenTypes.FUNCTION_WITH_N_ARGS && newTokens[i2].numberOfArguments === void 0) {
          newTokens[i2].numberOfArguments = 2;
        }
        newAr[x] = newAr[x] || [];
        for (var y = 0; y < newAr[x].length; y++) {
          if (newTokens[i2].token === newAr[x][y]) {
            temp = indexOfToken(newAr[x][y], tokens);
            break;
          }
        }
        if (temp === -1) {
          tokens.push(newTokens[i2]);
          newTokens[i2].precedence = preced[newTokens[i2].type];
          if (newAr.length <= newTokens[i2].token.length) {
            newAr[newTokens[i2].token.length] = [];
          }
          newAr[newTokens[i2].token.length].push(newTokens[i2].token);
        } else {
          tokens[temp] = newTokens[i2];
          newTokens[i2].precedence = preced[newTokens[i2].type];
        }
      }
    };
    function indexOfToken(key, tokens2) {
      for (var search = 0; search < tokens2.length; search++) {
        if (tokens2[search].token === key)
          return search;
      }
      return -1;
    }
    function tokenize(string) {
      var nodes = [];
      var length = string.length;
      var key, x, y;
      for (var i2 = 0; i2 < length; i2++) {
        if (i2 < length - 1 && string[i2] === " " && string[i2 + 1] === " ") {
          continue;
        }
        key = "";
        for (x = string.length - i2 > newAr.length - 2 ? newAr.length - 1 : string.length - i2; x > 0; x--) {
          if (newAr[x] === void 0)
            continue;
          for (y = 0; y < newAr[x].length; y++) {
            if (match(string, newAr[x][y], i2, x)) {
              key = newAr[x][y];
              y = newAr[x].length;
              x = 0;
            }
          }
        }
        i2 += key.length - 1;
        if (key === "") {
          throw new Mexp.Exception("Can't understand after " + string.slice(i2));
        }
        nodes.push(tokens[indexOfToken(key, tokens)]);
      }
      return nodes;
    }
    var changeSignObj = {
      value: Mexp.math.changeSign,
      type: 0,
      pre: 21,
      show: "-"
    };
    var closingParObj = {
      value: ")",
      show: ")",
      type: 5,
      pre: 0
    };
    var openingParObj = {
      value: "(",
      type: 4,
      pre: 0,
      show: "("
    };
    Mexp.lex = function(inp, tokens2) {
      "use strict";
      var str = [openingParObj];
      var ptc = [];
      var inpStr = inp;
      var allowed = type0;
      var bracToClose = 0;
      var asterick = empty;
      var prevKey = "";
      var i2;
      if (typeof tokens2 !== "undefined") {
        Mexp.addToken(tokens2);
      }
      var obj = {};
      var nodes = tokenize(inpStr);
      for (i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (node.type === 14) {
          if (i2 > 0 && i2 < nodes.length - 1 && nodes[i2 + 1].type === 1 && (nodes[i2 - 1].type === 1 || nodes[i2 - 1].type === 6)) {
            throw new Mexp.Exception("Unexpected Space");
          }
          continue;
        }
        var cToken = node.token;
        var cType = node.type;
        var cEv = node.value;
        var cPre = node.precedence;
        var cShow = node.show;
        var pre = str[str.length - 1];
        var j;
        for (j = ptc.length; j--; ) {
          if (ptc[j] === 0) {
            if ([0, 2, 3, 4, 5, 9, 11, 12, 13].indexOf(cType) !== -1) {
              if (allowed[cType] !== true) {
                throw new Mexp.Exception(cToken + " is not allowed after " + prevKey);
              }
              str.push(closingParObj);
              allowed = type1;
              asterick = type3Asterick;
              ptc.pop();
            }
          } else
            break;
        }
        if (allowed[cType] !== true) {
          throw new Mexp.Exception(cToken + " is not allowed after " + prevKey);
        }
        if (asterick[cType] === true) {
          cType = 2;
          cEv = Mexp.math.mul;
          cShow = "&times;";
          cPre = 3;
          i2 = i2 - 1;
        }
        obj = {
          value: cEv,
          type: cType,
          pre: cPre,
          show: cShow,
          numberOfArguments: node.numberOfArguments
        };
        if (cType === 0) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 2);
          str.push(obj);
          if (nodes[i2 + 1].type !== 4) {
            str.push(openingParObj);
            ptc.push(2);
          }
        } else if (cType === 1) {
          if (pre.type === 1) {
            pre.value += cEv;
            inc(ptc, 1);
          } else {
            str.push(obj);
          }
          allowed = type1;
          asterick = type1Asterick;
        } else if (cType === 2) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 2);
          str.push(obj);
        } else if (cType === 3) {
          str.push(obj);
          allowed = type1;
          asterick = type3Asterick;
        } else if (cType === 4) {
          inc(ptc, 1);
          bracToClose++;
          allowed = type0;
          asterick = empty;
          str.push(obj);
        } else if (cType === 5) {
          if (!bracToClose) {
            throw new Mexp.Exception("Closing parenthesis are more than opening one, wait What!!!");
          }
          bracToClose--;
          allowed = type1;
          asterick = type3Asterick;
          str.push(obj);
          inc(ptc, 1);
        } else if (cType === 6) {
          if (pre.hasDec) {
            throw new Mexp.Exception("Two decimals are not allowed in one number");
          }
          if (pre.type !== 1) {
            pre = {
              value: 0,
              type: 1,
              pre: 0
            };
            str.push(pre);
          }
          allowed = type6;
          inc(ptc, 1);
          asterick = empty;
          pre.value += cEv;
          pre.hasDec = true;
        } else if (cType === 7) {
          allowed = type1;
          asterick = type3Asterick;
          inc(ptc, 1);
          str.push(obj);
        }
        if (cType === 8) {
          allowed = type0;
          asterick = empty;
          inc(ptc, node.numberOfArguments + 2);
          str.push(obj);
          if (nodes[i2 + 1].type !== 4) {
            str.push(openingParObj);
            ptc.push(node.numberOfArguments + 2);
          }
        } else if (cType === 9) {
          if (pre.type === 9) {
            if (pre.value === Mexp.math.add) {
              pre.value = cEv;
              pre.show = cShow;
              inc(ptc, 1);
            } else if (pre.value === Mexp.math.sub && cShow === "-") {
              pre.value = Mexp.math.add;
              pre.show = "+";
              inc(ptc, 1);
            }
          } else if (pre.type !== 5 && pre.type !== 7 && pre.type !== 1 && pre.type !== 3 && pre.type !== 13) {
            if (cToken === "-") {
              allowed = type0;
              asterick = empty;
              inc(ptc, 2).push(2);
              str.push(changeSignObj);
              str.push(openingParObj);
            }
          } else {
            str.push(obj);
            inc(ptc, 2);
          }
          allowed = type0;
          asterick = empty;
        } else if (cType === 10) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 2);
          str.push(obj);
        } else if (cType === 11) {
          allowed = type0;
          asterick = empty;
          str.push(obj);
        } else if (cType === 12) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 6);
          str.push(obj);
          if (nodes[i2 + 1].type !== 4) {
            str.push(openingParObj);
            ptc.push(6);
          }
        } else if (cType === 13) {
          allowed = type1;
          asterick = type3Asterick;
          str.push(obj);
        }
        inc(ptc, -1);
        prevKey = cToken;
      }
      for (j = ptc.length; j--; ) {
        str.push(closingParObj);
      }
      if (allowed[5] !== true) {
        throw new Mexp.Exception("complete the expression");
      }
      while (bracToClose--) {
        str.push(closingParObj);
      }
      str.push(closingParObj);
      return new Mexp(str);
    };
    module.exports = Mexp;
  }
});

// node_modules/math-expression-evaluator/src/postfix.js
var require_postfix = __commonJS({
  "node_modules/math-expression-evaluator/src/postfix.js"(exports, module) {
    var Mexp = require_lexer();
    Mexp.prototype.toPostfix = function() {
      "use strict";
      var post = [], elem, popped, prep, pre, ele;
      var stack = [{ value: "(", type: 4, pre: 0 }];
      var arr = this.value;
      for (var i = 1; i < arr.length; i++) {
        if (arr[i].type === 1 || arr[i].type === 3 || arr[i].type === 13) {
          if (arr[i].type === 1)
            arr[i].value = Number(arr[i].value);
          post.push(arr[i]);
        } else if (arr[i].type === 4) {
          stack.push(arr[i]);
        } else if (arr[i].type === 5) {
          while ((popped = stack.pop()).type !== 4) {
            post.push(popped);
          }
        } else if (arr[i].type === 11) {
          while ((popped = stack.pop()).type !== 4) {
            post.push(popped);
          }
          stack.push(popped);
        } else {
          elem = arr[i];
          pre = elem.pre;
          ele = stack[stack.length - 1];
          prep = ele.pre;
          var flag = ele.value == "Math.pow" && elem.value == "Math.pow";
          if (pre > prep)
            stack.push(elem);
          else {
            while (prep >= pre && !flag || flag && pre < prep) {
              popped = stack.pop();
              ele = stack[stack.length - 1];
              post.push(popped);
              prep = ele.pre;
              flag = elem.value == "Math.pow" && ele.value == "Math.pow";
            }
            stack.push(elem);
          }
        }
      }
      return new Mexp(post);
    };
    module.exports = Mexp;
  }
});

// node_modules/math-expression-evaluator/src/postfix_evaluator.js
var require_postfix_evaluator = __commonJS({
  "node_modules/math-expression-evaluator/src/postfix_evaluator.js"(exports, module) {
    var Mexp = require_postfix();
    Mexp.prototype.postfixEval = function(UserDefined) {
      "use strict";
      UserDefined = UserDefined || {};
      UserDefined.PI = Math.PI;
      UserDefined.E = Math.E;
      var stack = [], pop1, pop2, pop3;
      var disp = [];
      var temp = "";
      var arr = this.value;
      var bool = typeof UserDefined.n !== "undefined";
      for (var i = 0; i < arr.length; i++) {
        if (arr[i].type === 1) {
          stack.push({ value: arr[i].value, type: 1 });
        } else if (arr[i].type === 3) {
          stack.push({ value: UserDefined[arr[i].value], type: 1 });
        } else if (arr[i].type === 0) {
          if (typeof stack[stack.length - 1].type === "undefined") {
            stack[stack.length - 1].value.push(arr[i]);
          } else
            stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value);
        } else if (arr[i].type === 7) {
          if (typeof stack[stack.length - 1].type === "undefined") {
            stack[stack.length - 1].value.push(arr[i]);
          } else
            stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value);
        } else if (arr[i].type === 8) {
          var popped = [];
          for (var x = 0; x < arr[i].numberOfArguments; x++) {
            popped.push(stack.pop().value);
          }
          stack.push({ type: 1, value: arr[i].value.apply(arr[i], popped.reverse()) });
        } else if (arr[i].type === 10) {
          pop1 = stack.pop();
          pop2 = stack.pop();
          if (typeof pop2.type === "undefined") {
            pop2.value = pop2.concat(pop1);
            pop2.value.push(arr[i]);
            stack.push(pop2);
          } else if (typeof pop1.type === "undefined") {
            pop1.unshift(pop2);
            pop1.push(arr[i]);
            stack.push(pop1);
          } else {
            stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) });
          }
        } else if (arr[i].type === 2 || arr[i].type === 9) {
          pop1 = stack.pop();
          pop2 = stack.pop();
          if (typeof pop2.type === "undefined") {
            pop2 = pop2.concat(pop1);
            pop2.push(arr[i]);
            stack.push(pop2);
          } else if (typeof pop1.type === "undefined") {
            pop1.unshift(pop2);
            pop1.push(arr[i]);
            stack.push(pop1);
          } else {
            stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) });
          }
        } else if (arr[i].type === 12) {
          pop1 = stack.pop();
          if (typeof pop1.type !== "undefined") {
            pop1 = [pop1];
          }
          pop2 = stack.pop();
          pop3 = stack.pop();
          stack.push({ type: 1, value: arr[i].value(pop3.value, pop2.value, new Mexp(pop1)) });
        } else if (arr[i].type === 13) {
          if (bool) {
            stack.push({ value: UserDefined[arr[i].value], type: 3 });
          } else
            stack.push([arr[i]]);
        }
      }
      if (stack.length > 1) {
        throw new Mexp.Exception("Uncaught Syntax error");
      }
      return stack[0].value > 1e15 ? "Infinity" : parseFloat(stack[0].value.toFixed(15));
    };
    Mexp.eval = function(str, tokens, obj) {
      if (typeof tokens === "undefined") {
        return this.lex(str).toPostfix().postfixEval();
      } else if (typeof obj === "undefined") {
        if (typeof tokens.length !== "undefined")
          return this.lex(str, tokens).toPostfix().postfixEval();
        else
          return this.lex(str).toPostfix().postfixEval(tokens);
      } else
        return this.lex(str, tokens).toPostfix().postfixEval(obj);
    };
    module.exports = Mexp;
  }
});

// node_modules/math-expression-evaluator/src/formula_evaluator.js
var require_formula_evaluator = __commonJS({
  "node_modules/math-expression-evaluator/src/formula_evaluator.js"(exports, module) {
    var Mexp = require_postfix_evaluator();
    Mexp.prototype.formulaEval = function() {
      "use strict";
      var stack = [], pop1, pop2, pop3;
      var disp = [];
      var temp = "";
      var arr = this.value;
      for (var i = 0; i < arr.length; i++) {
        if (arr[i].type === 1 || arr[i].type === 3) {
          disp.push({ value: arr[i].type === 3 ? arr[i].show : arr[i].value, type: 1 });
        } else if (arr[i].type === 13) {
          disp.push({ value: arr[i].show, type: 1 });
        } else if (arr[i].type === 0) {
          disp[disp.length - 1] = { value: arr[i].show + (arr[i].show != "-" ? "(" : "") + disp[disp.length - 1].value + (arr[i].show != "-" ? ")" : ""), type: 0 };
        } else if (arr[i].type === 7) {
          disp[disp.length - 1] = { value: (disp[disp.length - 1].type != 1 ? "(" : "") + disp[disp.length - 1].value + (disp[disp.length - 1].type != 1 ? ")" : "") + arr[i].show, type: 7 };
        } else if (arr[i].type === 10) {
          pop1 = disp.pop();
          pop2 = disp.pop();
          if (arr[i].show === "P" || arr[i].show === "C")
            disp.push({ value: "<sup>" + pop2.value + "</sup>" + arr[i].show + "<sub>" + pop1.value + "</sub>", type: 10 });
          else
            disp.push({ value: (pop2.type != 1 ? "(" : "") + pop2.value + (pop2.type != 1 ? ")" : "") + "<sup>" + pop1.value + "</sup>", type: 1 });
        } else if (arr[i].type === 2 || arr[i].type === 9) {
          pop1 = disp.pop();
          pop2 = disp.pop();
          disp.push({ value: (pop2.type != 1 ? "(" : "") + pop2.value + (pop2.type != 1 ? ")" : "") + arr[i].show + (pop1.type != 1 ? "(" : "") + pop1.value + (pop1.type != 1 ? ")" : ""), type: arr[i].type });
        } else if (arr[i].type === 12) {
          pop1 = disp.pop();
          pop2 = disp.pop();
          pop3 = disp.pop();
          disp.push({ value: arr[i].show + "(" + pop3.value + "," + pop2.value + "," + pop1.value + ")", type: 12 });
        }
      }
      return disp[0].value;
    };
    module.exports = Mexp;
  }
});

// node_modules/reduce-css-calc/index.js
var require_reduce_css_calc = __commonJS({
  "node_modules/reduce-css-calc/index.js"(exports, module) {
    var balanced = require_balanced_match();
    var reduceFunctionCall = require_reduce_function_call();
    var mexp = require_formula_evaluator();
    var MAX_STACK = 100;
    var NESTED_CALC_RE = /(\+|\-|\*|\\|[^a-z]|)(\s*)(\()/g;
    var stack;
    module.exports = reduceCSSCalc2;
    function reduceCSSCalc2(value, decimalPrecision) {
      stack = 0;
      decimalPrecision = Math.pow(10, decimalPrecision === void 0 ? 5 : decimalPrecision);
      value = value.replace(/\n+/g, " ");
      function evaluateExpression(expression, functionIdentifier, call) {
        if (stack++ > MAX_STACK) {
          stack = 0;
          throw new Error("Call stack overflow for " + call);
        }
        if (expression === "") {
          throw new Error(functionIdentifier + "(): '" + call + "' must contain a non-whitespace string");
        }
        expression = evaluateNestedExpression(expression, call);
        var units = getUnitsInExpression(expression);
        if (units.length > 1 || expression.indexOf("var(") > -1) {
          return functionIdentifier + "(" + expression + ")";
        }
        var unit = units[0] || "";
        if (unit === "%") {
          expression = expression.replace(/\b[0-9\.]+%/g, function(percent) {
            return parseFloat(percent.slice(0, -1)) * 0.01;
          });
        }
        var toEvaluate = expression.replace(new RegExp(unit, "gi"), "");
        var result;
        try {
          result = mexp.eval(toEvaluate);
        } catch (e) {
          return functionIdentifier + "(" + expression + ")";
        }
        if (unit === "%") {
          result *= 100;
        }
        if (functionIdentifier.length || unit === "%") {
          result = Math.round(result * decimalPrecision) / decimalPrecision;
        }
        result += unit;
        return result;
      }
      function evaluateNestedExpression(expression, call) {
        expression = expression.replace(/((?:\-[a-z]+\-)?calc)/g, "");
        var evaluatedPart = "";
        var nonEvaluatedPart = expression;
        var matches;
        while (matches = NESTED_CALC_RE.exec(nonEvaluatedPart)) {
          if (matches[0].index > 0) {
            evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index);
          }
          var balancedExpr = balanced("(", ")", nonEvaluatedPart.substring([0].index));
          if (balancedExpr.body === "") {
            throw new Error("'" + expression + "' must contain a non-whitespace string");
          }
          var evaluated = evaluateExpression(balancedExpr.body, "", call);
          evaluatedPart += balancedExpr.pre + evaluated;
          nonEvaluatedPart = balancedExpr.post;
        }
        return evaluatedPart + nonEvaluatedPart;
      }
      return reduceFunctionCall(value, /((?:\-[a-z]+\-)?calc)\(/, evaluateExpression);
    }
    function getUnitsInExpression(expression) {
      var uniqueUnits = [];
      var uniqueLowerCaseUnits = [];
      var unitRegEx = /[\.0-9]([%a-z]+)/gi;
      var matches = unitRegEx.exec(expression);
      while (matches) {
        if (!matches || !matches[1]) {
          continue;
        }
        if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {
          uniqueUnits.push(matches[1]);
          uniqueLowerCaseUnits.push(matches[1].toLowerCase());
        }
        matches = unitRegEx.exec(expression);
      }
      return uniqueUnits;
    }
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map = getNative(root, "Map");
    module.exports = Map;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    module.exports = memoize2;
  }
});

// node_modules/@visx/text/esm/Text.js
var import_react2 = __toESM(require_react());

// node_modules/@visx/text/esm/hooks/useText.js
var import_react = __toESM(require_react());
var import_reduce_css_calc = __toESM(require_reduce_css_calc());

// node_modules/@visx/text/esm/util/getStringWidth.js
var import_memoize = __toESM(require_memoize());
var MEASUREMENT_ELEMENT_ID = "__react_svg_text_measurement_id";
function getStringWidth(str, style) {
  try {
    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);
    if (!textEl) {
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("aria-hidden", "true");
      svg.style.width = "0";
      svg.style.height = "0";
      svg.style.position = "absolute";
      svg.style.top = "-100%";
      svg.style.left = "-100%";
      textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textEl.setAttribute("id", MEASUREMENT_ELEMENT_ID);
      svg.appendChild(textEl);
      document.body.appendChild(svg);
    }
    Object.assign(textEl.style, style);
    textEl.textContent = str;
    return textEl.getComputedTextLength();
  } catch (e) {
    return null;
  }
}
var getStringWidth_default = (0, import_memoize.default)(getStringWidth, function(str, style) {
  return str + "_" + JSON.stringify(style);
});

// node_modules/@visx/text/esm/hooks/useText.js
var _excluded = ["verticalAnchor", "scaleToFit", "angle", "width", "lineHeight", "capHeight", "children", "style"];
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isNumber(val) {
  return typeof val === "number";
}
function isXOrYInValid(xOrY) {
  return typeof xOrY === "number" && Number.isFinite(xOrY) || typeof xOrY === "string";
}
function useText(props) {
  var _props$verticalAnchor = props.verticalAnchor, verticalAnchor = _props$verticalAnchor === void 0 ? "end" : _props$verticalAnchor, _props$scaleToFit = props.scaleToFit, scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit, angle = props.angle, width = props.width, _props$lineHeight = props.lineHeight, lineHeight = _props$lineHeight === void 0 ? "1em" : _props$lineHeight, _props$capHeight = props.capHeight, capHeight = _props$capHeight === void 0 ? "0.71em" : _props$capHeight, children = props.children, style = props.style, textProps = _objectWithoutPropertiesLoose(props, _excluded);
  var _textProps$x = textProps.x, x = _textProps$x === void 0 ? 0 : _textProps$x, _textProps$y = textProps.y, y = _textProps$y === void 0 ? 0 : _textProps$y;
  var isXOrYNotValid = !isXOrYInValid(x) || !isXOrYInValid(y);
  var _useMemo = (0, import_react.useMemo)(function() {
    var words = children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/);
    return {
      wordsWithWidth: words.map(function(word) {
        return {
          word,
          wordWidth: getStringWidth_default(word, style) || 0
        };
      }),
      spaceWidth: getStringWidth_default("\xA0", style) || 0
    };
  }, [children, style]), wordsWithWidth = _useMemo.wordsWithWidth, spaceWidth = _useMemo.spaceWidth;
  var wordsByLines = (0, import_react.useMemo)(function() {
    if (isXOrYNotValid) {
      return [];
    }
    if (width || scaleToFit) {
      return wordsWithWidth.reduce(function(result, _ref) {
        var word = _ref.word, wordWidth = _ref.wordWidth;
        var currentLine = result[result.length - 1];
        if (currentLine && (width == null || scaleToFit || (currentLine.width || 0) + wordWidth + spaceWidth < width)) {
          currentLine.words.push(word);
          currentLine.width = currentLine.width || 0;
          currentLine.width += wordWidth + spaceWidth;
        } else {
          var newLine = {
            words: [word],
            width: wordWidth
          };
          result.push(newLine);
        }
        return result;
      }, []);
    }
    return [{
      words: children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/)
    }];
  }, [isXOrYNotValid, width, scaleToFit, children, wordsWithWidth, spaceWidth]);
  var startDy = (0, import_react.useMemo)(function() {
    var startDyStr = isXOrYNotValid ? "" : verticalAnchor === "start" ? (0, import_reduce_css_calc.default)("calc(" + capHeight + ")") : verticalAnchor === "middle" ? (0, import_reduce_css_calc.default)("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))") : (0, import_reduce_css_calc.default)("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");
    return startDyStr;
  }, [isXOrYNotValid, verticalAnchor, capHeight, wordsByLines.length, lineHeight]);
  var transform = (0, import_react.useMemo)(function() {
    var transforms = [];
    if (isXOrYNotValid) {
      return "";
    }
    if (isNumber(x) && isNumber(y) && isNumber(width) && scaleToFit && wordsByLines.length > 0) {
      var lineWidth = wordsByLines[0].width || 1;
      var sx = scaleToFit === "shrink-only" ? Math.min(width / lineWidth, 1) : width / lineWidth;
      var sy = sx;
      var originX = x - sx * x;
      var originY = y - sy * y;
      transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
    }
    if (angle) {
      transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");
    }
    return transforms.length > 0 ? transforms.join(" ") : "";
  }, [isXOrYNotValid, x, y, width, scaleToFit, wordsByLines, angle]);
  return {
    wordsByLines,
    startDy,
    transform
  };
}

// node_modules/@visx/text/esm/Text.js
var _excluded2 = ["dx", "dy", "textAnchor", "innerRef", "innerTextRef", "verticalAnchor", "angle", "lineHeight", "scaleToFit", "capHeight", "width"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var SVG_STYLE = {
  overflow: "visible"
};
function Text(props) {
  var _props$dx = props.dx, dx = _props$dx === void 0 ? 0 : _props$dx, _props$dy = props.dy, dy = _props$dy === void 0 ? 0 : _props$dy, _props$textAnchor = props.textAnchor, textAnchor = _props$textAnchor === void 0 ? "start" : _props$textAnchor, innerRef = props.innerRef, innerTextRef = props.innerTextRef, verticalAnchor = props.verticalAnchor, angle = props.angle, _props$lineHeight = props.lineHeight, lineHeight = _props$lineHeight === void 0 ? "1em" : _props$lineHeight, _props$scaleToFit = props.scaleToFit, scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit, capHeight = props.capHeight, width = props.width, textProps = _objectWithoutPropertiesLoose2(props, _excluded2);
  var _textProps$x = textProps.x, x = _textProps$x === void 0 ? 0 : _textProps$x, fontSize = textProps.fontSize;
  var _useText = useText(props), wordsByLines = _useText.wordsByLines, startDy = _useText.startDy, transform = _useText.transform;
  return import_react2.default.createElement("svg", {
    ref: innerRef,
    x: dx,
    y: dy,
    fontSize,
    style: SVG_STYLE
  }, wordsByLines.length > 0 ? import_react2.default.createElement("text", _extends({
    ref: innerTextRef,
    transform
  }, textProps, {
    textAnchor
  }), wordsByLines.map(function(line, index) {
    return import_react2.default.createElement("tspan", {
      key: index,
      x,
      dy: index === 0 ? startDy : lineHeight
    }, line.words.join(" "));
  })) : null);
}
export {
  Text,
  getStringWidth_default as getStringWidth,
  useText
};
//# sourceMappingURL=@visx_text.js.map
